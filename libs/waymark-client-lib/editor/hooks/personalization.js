/* eslint-disable import/prefer-default-export */
// Vendor
import _ from 'lodash';
import {
    useCallback
} from 'react';

// Editor
import {
    useApplyBrandColorsToConfiguration
} from 'editor/hooks/colorPersonalization.js';
import {
    useEditorDispatch
} from 'editor/providers/EditorStateProvider.js';
import {
    useEditorFieldsOfType
} from 'editor/providers/EditorFormDescriptionProvider.js';
import {
    VideoEditingFieldTypes
} from 'editor/constants/Editor';
import {
    useApplyAuxiliaryAudioToConfiguration
} from './auxiliaryAudioPersonalization.js';

/**
 * Hook returns a function which takes a configuration object and updates all "main"
 * fields in the video with the values from that configuration.
 * (main fields meaning text, image, video and switches)
 */
export function useUpdateMainFieldValuesWithConfiguration() {
    const {
        setFullConfiguration
    } = useEditorDispatch();

    const mainFields = useEditorFieldsOfType(VideoEditingFieldTypes.main);
    const fontField = useEditorFieldsOfType(VideoEditingFieldTypes.font);

    const fontOverrides = fontField ? .fontOverrides;

    /**
     * Function takes a full configuration object and updates all main field values
     * (ie, text, images, video) with values from that given configuration.
     *
     * This is useful for auto-personalization since we want personalization to
     * ignore colors and audio since we don't have good mechanisms for
     * setting truly personalized content for those fields yet.
     *
     * @param {Object}  newConfiguration  A new configuration object which we only want to apply main field values from
     * @param {boolean} [shouldRespectSelectedSwitchOptions=true]  Whether we should skip changing the currently selected
     *                                                              options for any layout selector fields
     *
     * @returns {Object}  The final updated configuration
     */
    return useCallback(
        (newConfiguration, shouldRespectLayoutSelectorSelections = true) => {
            let finalConfiguration;

            setFullConfiguration((currentConfiguration) => {
                finalConfiguration = _.cloneDeep(currentConfiguration);

                function updateConfigurationForPaths(paths) {
                    paths.forEach((path) => {
                        const newValue = _.get(newConfiguration, path);

                        _.set(finalConfiguration, path, newValue);
                    });
                }

                function updateFieldConfigurationValues(field) {
                    const isLayoutSelectorField = field.type === VideoEditingFieldTypes.layoutSelector;

                    // Only update the configuration's value for this field if it's not a layout selector
                    // OR we don't care about respecting layout selectors' currently selected options
                    if (!isLayoutSelectorField || !shouldRespectLayoutSelectorSelections) {
                        updateConfigurationForPaths(field.paths);
                    }

                    if (isLayoutSelectorField) {
                        // If we have a layout selector field, recursively update the configuration values for every option's content fields
                        field.selectOptions.forEach((selectedLayoutField) =>
                            selectedLayoutField.contentFields.forEach((layoutContentField) =>
                                updateFieldConfigurationValues(layoutContentField),
                            ),
                        );
                    }
                }

                // Copy over values from the given configuration to each main field
                mainFields.forEach((field) => updateFieldConfigurationValues(field));

                if (fontOverrides) {
                    Object.values(fontOverrides).forEach((fontOverride) => {
                        updateConfigurationForPaths(fontOverride.paths);
                    });
                }

                // Set the full editor configuration to match the merged configuration we created
                return finalConfiguration;
            });

            return finalConfiguration;
        }, [mainFields, setFullConfiguration, fontOverrides],
    );
}

/**
 * @typedef VideoDescriptor
 *
 * A subset of a template bundle combined with a variant configuration. Generated by the Autofill Service.
 *
 * @property {string} templateSlug - Fetched template bundle VideoTemplate slug
 * @property {Object} __activeConfiguration - Configuration that has been personalized with business data
 * @property {Object} __cachedEditingForm - The TemplateBundle editing form
 */

/**
 * Hook returns a function which takes a VideoDescriptor and updates the video's configuration
 * with that descriptor's personalizedconfiguration.
 */
export function useApplyVideoDescriptorToConfiguration() {
    const updateMainFieldValuesWithConfiguration = useUpdateMainFieldValuesWithConfiguration();
    const applyBrandColorsToConfiguration = useApplyBrandColorsToConfiguration();
    const applyAuxiliaryAudioToConfiguration = useApplyAuxiliaryAudioToConfiguration();

    /**
     * Applies a newly loaded video descriptor to the video's configuration
     *
     * @param {VideoDescriptor} videoDescriptor - Video descriptor whose configuration should be applied to the video
     */
    const applyVideoDescriptorToConfiguration = useCallback(
        async (videoDescriptor, businessGUID) => {
            // eslint-disable-next-line no-underscore-dangle
            const personalizedConfiguration = videoDescriptor.__activeConfiguration;

            // Only apply changes from the personalized configuration to "main" fields in the
            // video (text, image, fonts, and switches)
            updateMainFieldValuesWithConfiguration(personalizedConfiguration);

            // Update auxiliaryAudio (voice over)
            await applyAuxiliaryAudioToConfiguration(personalizedConfiguration);

            // TODO: applying brand colors should probably be performed in the autofill service rather
            // than here eventually
            const configurationWithBrandColors = await applyBrandColorsToConfiguration(businessGUID);

            return configurationWithBrandColors;
        }, [
            updateMainFieldValuesWithConfiguration,
            applyAuxiliaryAudioToConfiguration,
            applyBrandColorsToConfiguration,
        ],
    );

    return applyVideoDescriptorToConfiguration;
}